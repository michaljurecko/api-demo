// DO NOT EDIT. Code generated by entitygen. For modifications use "make gen-model".

package model

import (
	"context"
	"errors"
	webapi "github.com/michaljurecko/ch-demo/internal/pkg/common/dataverse/webapi"
	"net/http"
	"time"
)

// DiceRoll - This table contains records of dice rolls associated with characters.
type DiceRoll struct {
	// original field stores snapshot of the entity state for the Update operation, see TrackChanges method.
	original   *DiceRoll
	ID         string                   `json:"cr568_dicerollid,omitempty"`
	DiceRoll   string                   `json:"cr568_diceroll1"`
	RollResult int                      `json:"cr568_rollresult"`
	RollDate   time.Time                `json:"cr568_rolldate"`
	Character  webapi.Lookup[Character] `json:"_cr568_characterid_value"`
	ActionType string                   `json:"cr568_actiontype"`
}

// TrackChanges internally stores entity actual state to track changes for the Update operation.
func (e *DiceRoll) TrackChanges() {
	clone := *e
	e.original = &clone
}

// resetChanges after the Update operation.
func (e *DiceRoll) resetChanges() {
	e.original = nil
}

type DiceRollRepository struct {
	client *webapi.Client
}

func newDiceRollRepository(client *webapi.Client) *DiceRollRepository {
	return &DiceRollRepository{client: client}
}

// Create entity. After successful operation, the new primary ID will be set to the original entity.
func (r *DiceRollRepository) Create(entity *DiceRoll) *webapi.APIRequest[DiceRoll] {
	payload, err := r.createPayload(entity)
	if err != nil {
		return webapi.NewAPIRequestError[DiceRoll](entity, err)
	}

	path := "cr568_dicerolls"
	result := entity
	httpReq := webapi.NewHTTPRequest(result, r.client, http.MethodPost, path, payload)
	httpReq.Header("Prefer", "return=representation")
	httpReq.ExpectStatus(http.StatusCreated)
	return webapi.NewAPIRequest(result, httpReq)
}

// Update entity. A diff of modifications is generated and saved via API.
// Before making changes, it is necessary to call the TrackChanges entity method.
func (r *DiceRollRepository) Update(entity *DiceRoll) *webapi.APIRequest[DiceRoll] {

	if entity.original == nil {
		err := errors.New("changes are not tracked: use \"TrackChanges\" entity method to track changes and allow \"Update\" operation")
		return webapi.NewAPIRequestError[DiceRoll](entity, err)
	}

	payload, err := r.updatePayload(entity.original, entity)
	if err != nil {
		return webapi.NewAPIRequestError[DiceRoll](entity, err)
	}

	id := entity.ID
	path := "cr568_dicerolls" + "(" + webapi.ID(id) + ")"
	result := entity
	httpReq := webapi.NewHTTPRequest(result, r.client, http.MethodPatch, path, payload)
	httpReq.Header("If-Match", "*") // prevent create if entity not exists
	httpReq.Header("Prefer", "return=representation")
	httpReq.OnSuccess(func(ctx context.Context, c *DiceRoll) error {
		c.resetChanges()
		return nil
	})
	return webapi.NewAPIRequest(result, httpReq)
}

// Delete entity by the ID.
func (r *DiceRollRepository) Delete(id string) *webapi.APIRequest[webapi.NoResult] {
	path := "cr568_dicerolls" + "(" + webapi.ID(id) + ")"
	httpReq := webapi.NewHTTPRequest(&webapi.NoResult{}, r.client, http.MethodDelete, path, nil)
	httpReq.ExpectStatus(http.StatusNoContent)
	return webapi.NewAPIRequest(&webapi.NoResult{}, httpReq)
}

func (r *DiceRollRepository) All() *webapi.APIRequest[webapi.Collection[DiceRoll]] {
	path := "cr568_dicerolls"
	result := &webapi.Collection[DiceRoll]{}
	httpReq := webapi.NewHTTPRequest(result, r.client, http.MethodGet, path, nil)
	return webapi.NewAPIRequest(result, httpReq)
}

func (r *DiceRollRepository) ByID(id string) *webapi.APIRequest[DiceRoll] {
	path := "cr568_dicerolls" + "(" + webapi.ID(id) + ")"
	result := &DiceRoll{}
	httpReq := webapi.NewHTTPRequest(result, r.client, http.MethodGet, path, nil)
	return webapi.NewAPIRequest(result, httpReq)
}

func (r *DiceRollRepository) ByCharacter(id string) *webapi.APIRequest[webapi.Collection[DiceRoll]] {
	path := "cr568_dicerolls"
	result := &webapi.Collection[DiceRoll]{}
	httpReq := webapi.NewHTTPRequest(result, r.client, http.MethodGet, path, nil)
	httpReq.Filter("cr568_characterid eq '" + webapi.ID(id) + "'")
	return webapi.NewAPIRequest(result, httpReq)
}

// createPayload method generates payload for the Create operation.
func (r *DiceRollRepository) createPayload(entity *DiceRoll) (map[string]any, error) {
	payload := map[string]any{}
	payload["cr568_diceroll1"] = entity.DiceRoll
	payload["cr568_rollresult"] = entity.RollResult
	payload["cr568_rolldate"] = entity.RollDate
	{
		idOrNil, err := lookupFullIDOrNil(entity.Character)
		if err != nil {
			return nil, err
		}
		payload["cr568_CharacterID@odata.bind"] = idOrNil
	}
	payload["cr568_actiontype"] = entity.ActionType
	return payload, nil
}

// updatePayload method generates diff of original and modified entity state for the Update operation.
func (r *DiceRollRepository) updatePayload(original, modified *DiceRoll) (map[string]any, error) {
	payload := map[string]any{}
	if original.DiceRoll != modified.DiceRoll {
		payload["cr568_diceroll1"] = modified.DiceRoll
	}
	if original.RollResult != modified.RollResult {
		payload["cr568_rollresult"] = modified.RollResult
	}
	if original.RollDate != modified.RollDate {
		payload["cr568_rolldate"] = modified.RollDate
	}
	if original.Character.ID() != modified.Character.ID() {
		idOrNil, err := lookupFullIDOrNil(modified.Character)
		if err != nil {
			return nil, err
		}
		payload["cr568_CharacterID@odata.bind"] = idOrNil
	}
	if original.ActionType != modified.ActionType {
		payload["cr568_actiontype"] = modified.ActionType
	}
	return payload, nil
}
