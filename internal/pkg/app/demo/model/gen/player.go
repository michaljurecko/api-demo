// DO NOT EDIT. Code generated by entitygen. For modifications use "make gen-model".

package model

import (
	"context"
	"errors"
	webapi "github.com/michaljurecko/ch-demo/internal/pkg/common/dataverse/webapi"
	"net/http"
)

// Player - This table contains records of player information
type Player struct {
	// original field stores snapshot of the entity state for the Update operation, see TrackChanges method.
	original  *Player
	ID        string `json:"cr568_playerid,omitempty"`
	FirstName string `json:"cr568_firstname"`
	LastName  string `json:"cr568_lastname"`
	Phone     string `json:"cr568_phone"`
	Email     string `json:"cr568_email"`
	IC        string `json:"cr568_ic"`
	VATID     string `json:"cr568_vatid"`
	Address   string `json:"cr568_address"`
}

// TrackChanges internally stores entity actual state to track changes for the Update operation.
func (e *Player) TrackChanges() {
	clone := *e
	e.original = &clone
}

// resetChanges after the Update operation.
func (e *Player) resetChanges() {
	e.original = nil
}

type PlayerRepository struct {
	client *webapi.Client
}

func newPlayerRepository(client *webapi.Client) *PlayerRepository {
	return &PlayerRepository{client: client}
}

// Create entity. After successful operation, the new primary ID will be set to the original entity.
func (r *PlayerRepository) Create(entity *Player) *webapi.APIRequest[Player] {
	payload, err := r.createPayload(entity)
	if err != nil {
		return webapi.NewAPIRequestError[Player](entity, err)
	}

	path := "cr568_players"
	result := entity
	httpReq := webapi.NewHTTPRequest(result, r.client, http.MethodPost, path, payload)
	httpReq.Header("Prefer", "return=representation")
	httpReq.ExpectStatus(http.StatusCreated)
	return webapi.NewAPIRequest(result, httpReq)
}

// Update entity. A diff of modifications is generated and saved via API.
// Before making changes, it is necessary to call the TrackChanges entity method.
func (r *PlayerRepository) Update(entity *Player) *webapi.APIRequest[Player] {

	if entity.original == nil {
		err := errors.New("changes are not tracked: use \"TrackChanges\" entity method to track changes and allow \"Update\" operation")
		return webapi.NewAPIRequestError[Player](entity, err)
	}

	payload, err := r.updatePayload(entity.original, entity)
	if err != nil {
		return webapi.NewAPIRequestError[Player](entity, err)
	}

	id := entity.ID
	path := "cr568_players" + "(" + webapi.ID(id) + ")"
	result := entity
	httpReq := webapi.NewHTTPRequest(result, r.client, http.MethodPatch, path, payload)
	httpReq.Header("If-Match", "*") // prevent create if entity not exists
	httpReq.Header("Prefer", "return=representation")
	httpReq.OnSuccess(func(ctx context.Context, c *Player) error {
		c.resetChanges()
		return nil
	})
	return webapi.NewAPIRequest(result, httpReq)
}

// Delete entity by the ID.
func (r *PlayerRepository) Delete(id string) *webapi.APIRequest[webapi.NoResult] {
	path := "cr568_players" + "(" + webapi.ID(id) + ")"
	httpReq := webapi.NewHTTPRequest(&webapi.NoResult{}, r.client, http.MethodDelete, path, nil)
	httpReq.ExpectStatus(http.StatusNoContent)
	return webapi.NewAPIRequest(&webapi.NoResult{}, httpReq)
}

func (r *PlayerRepository) All() *webapi.APIRequest[webapi.Collection[Player]] {
	path := "cr568_players"
	result := &webapi.Collection[Player]{}
	httpReq := webapi.NewHTTPRequest(result, r.client, http.MethodGet, path, nil)
	return webapi.NewAPIRequest(result, httpReq)
}

func (r *PlayerRepository) ByID(id string) *webapi.APIRequest[Player] {
	path := "cr568_players" + "(" + webapi.ID(id) + ")"
	result := &Player{}
	httpReq := webapi.NewHTTPRequest(result, r.client, http.MethodGet, path, nil)
	return webapi.NewAPIRequest(result, httpReq)
}

// createPayload method generates payload for the Create operation.
func (r *PlayerRepository) createPayload(entity *Player) (map[string]any, error) {
	payload := map[string]any{}
	payload["cr568_firstname"] = entity.FirstName
	payload["cr568_lastname"] = entity.LastName
	payload["cr568_phone"] = entity.Phone
	payload["cr568_email"] = entity.Email
	payload["cr568_ic"] = entity.IC
	payload["cr568_vatid"] = entity.VATID
	payload["cr568_address"] = entity.Address
	return payload, nil
}

// updatePayload method generates diff of original and modified entity state for the Update operation.
func (r *PlayerRepository) updatePayload(original, modified *Player) (map[string]any, error) {
	payload := map[string]any{}
	if original.FirstName != modified.FirstName {
		payload["cr568_firstname"] = modified.FirstName
	}
	if original.LastName != modified.LastName {
		payload["cr568_lastname"] = modified.LastName
	}
	if original.Phone != modified.Phone {
		payload["cr568_phone"] = modified.Phone
	}
	if original.Email != modified.Email {
		payload["cr568_email"] = modified.Email
	}
	if original.IC != modified.IC {
		payload["cr568_ic"] = modified.IC
	}
	if original.VATID != modified.VATID {
		payload["cr568_vatid"] = modified.VATID
	}
	if original.Address != modified.Address {
		payload["cr568_address"] = modified.Address
	}
	return payload, nil
}
