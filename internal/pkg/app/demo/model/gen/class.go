// DO NOT EDIT. Code generated by entitygen. For modifications use "make gen-model".

package model

import (
	"context"
	"errors"
	webapi "github.com/michaljurecko/ch-demo/internal/pkg/common/dataverse/webapi"
	"net/http"
)

// Class - This table contains records of character classes.
type Class struct {
	// original field stores snapshot of the entity state for the Update operation, see TrackChanges method.
	original         *Class
	ID               string `json:"cr568_classid,omitempty"`
	Name             string `json:"cr568_classname"`
	StrengthBase     int    `json:"cr568_strengthbase"`
	Description      string `json:"cr568_description"`
	IntelligenceBase int    `json:"cr568_intelligencebase"`
	CharismaBase     int    `json:"cr568_charismabase"`
	DexterityBase    int    `json:"cr568_dexteritybase"`
}

// TrackChanges internally stores entity actual state to track changes for the Update operation.
func (e *Class) TrackChanges() {
	clone := *e
	e.original = &clone
}

// resetChanges after the Update operation.
func (e *Class) resetChanges() {
	e.original = nil
}

type ClassRepository struct {
	client *webapi.Client
}

func newClassRepository(client *webapi.Client) *ClassRepository {
	return &ClassRepository{client: client}
}

// Create entity. After successful operation, the new primary ID will be set to the original entity.
func (r *ClassRepository) Create(entity *Class) *webapi.APIRequest[Class] {
	payload, err := r.createPayload(entity)
	if err != nil {
		return webapi.NewAPIRequestError[Class](entity, err)
	}

	path := "cr568_classes"
	result := entity
	httpReq := webapi.NewHTTPRequest(result, r.client, http.MethodPost, path, payload)
	httpReq.Header("Prefer", "return=representation")
	httpReq.ExpectStatus(http.StatusCreated)
	return webapi.NewAPIRequest(result, httpReq)
}

// Update entity. A diff of modifications is generated and saved via API.
// Before making changes, it is necessary to call the TrackChanges entity method.
func (r *ClassRepository) Update(entity *Class) *webapi.APIRequest[Class] {

	if entity.original == nil {
		err := errors.New("changes are not tracked: use \"TrackChanges\" entity method to track changes and allow \"Update\" operation")
		return webapi.NewAPIRequestError[Class](entity, err)
	}

	payload, err := r.updatePayload(entity.original, entity)
	if err != nil {
		return webapi.NewAPIRequestError[Class](entity, err)
	}

	id := entity.ID
	path := "cr568_classes" + "(" + webapi.ID(id) + ")"
	result := entity
	httpReq := webapi.NewHTTPRequest(result, r.client, http.MethodPatch, path, payload)
	httpReq.Header("If-Match", "*") // prevent create if entity not exists
	httpReq.Header("Prefer", "return=representation")
	httpReq.OnSuccess(func(ctx context.Context, c *Class) error {
		c.resetChanges()
		return nil
	})
	return webapi.NewAPIRequest(result, httpReq)
}

// Delete entity by the ID.
func (r *ClassRepository) Delete(id string) *webapi.APIRequest[webapi.NoResult] {
	path := "cr568_classes" + "(" + webapi.ID(id) + ")"
	httpReq := webapi.NewHTTPRequest(&webapi.NoResult{}, r.client, http.MethodDelete, path, nil)
	httpReq.ExpectStatus(http.StatusNoContent)
	return webapi.NewAPIRequest(&webapi.NoResult{}, httpReq)
}

func (r *ClassRepository) All() *webapi.APIRequest[webapi.Collection[Class]] {
	path := "cr568_classes"
	result := &webapi.Collection[Class]{}
	httpReq := webapi.NewHTTPRequest(result, r.client, http.MethodGet, path, nil)
	return webapi.NewAPIRequest(result, httpReq)
}

func (r *ClassRepository) ByID(id string) *webapi.APIRequest[Class] {
	path := "cr568_classes" + "(" + webapi.ID(id) + ")"
	result := &Class{}
	httpReq := webapi.NewHTTPRequest(result, r.client, http.MethodGet, path, nil)
	return webapi.NewAPIRequest(result, httpReq)
}

// createPayload method generates payload for the Create operation.
func (r *ClassRepository) createPayload(entity *Class) (map[string]any, error) {
	payload := map[string]any{}
	payload["cr568_classname"] = entity.Name
	payload["cr568_strengthbase"] = entity.StrengthBase
	payload["cr568_description"] = entity.Description
	payload["cr568_intelligencebase"] = entity.IntelligenceBase
	payload["cr568_charismabase"] = entity.CharismaBase
	payload["cr568_dexteritybase"] = entity.DexterityBase
	return payload, nil
}

// updatePayload method generates diff of original and modified entity state for the Update operation.
func (r *ClassRepository) updatePayload(original, modified *Class) (map[string]any, error) {
	payload := map[string]any{}
	if original.Name != modified.Name {
		payload["cr568_classname"] = modified.Name
	}
	if original.StrengthBase != modified.StrengthBase {
		payload["cr568_strengthbase"] = modified.StrengthBase
	}
	if original.Description != modified.Description {
		payload["cr568_description"] = modified.Description
	}
	if original.IntelligenceBase != modified.IntelligenceBase {
		payload["cr568_intelligencebase"] = modified.IntelligenceBase
	}
	if original.CharismaBase != modified.CharismaBase {
		payload["cr568_charismabase"] = modified.CharismaBase
	}
	if original.DexterityBase != modified.DexterityBase {
		payload["cr568_dexteritybase"] = modified.DexterityBase
	}
	return payload, nil
}
