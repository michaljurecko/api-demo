// Package entitygen generates Go structs from OData entity metadata for streamlined development.
package entitygen

import (
	"context"
	"log/slog"
	"maps"
	"os"
	"slices"
	"strings"

	"github.com/michaljurecko/ch-demo/internal/pkg/common/dataverse/metadata"

	j "github.com/dave/jennifer/jen"
)

const (
	headerComment = `DO NOT EDIT. Code generated by entitygen. For modifications use "make gen-model".`
	webAPIPkg     = "github.com/michaljurecko/ch-demo/internal/pkg/common/dataverse/webapi"
)

const (
	lookupFieldType = "Lookup"
	fileMode        = os.O_CREATE | os.O_WRONLY
	filePerm        = 0o644
	dirPerm         = 0o755
)

type generator struct {
	pkgName      string
	api          *metadata.API
	typeToStruct map[string]string
}

type genFile struct {
	FileName string
	File     *j.File
}

//nolint:gochecknoglobals // code generator, not production code
var (
	clientVar   = j.Id("client")
	clientParam = clientVar.Clone().Op("*").Qual(webAPIPkg, "Client")
	idVar       = j.Id("id")
	entityVar   = j.Id("entity")
	originalVar = j.Id("original")
	modifiedVar = j.Id("modified")
	pathVar     = j.Id("path")
	resultVar   = j.Id("result")
	httpReqVar  = j.Id("httpReq")
	payloadVar  = j.Id("payload")
)

func Generate(
	ctx context.Context,
	logger *slog.Logger,
	api *metadata.API,
	pkgName,
	targetDir string,
) error {
	files, err := newGenerator(pkgName, api).Generate(ctx)
	if err != nil {
		return err
	}

	return newFsWriter(logger, targetDir).WriteFiles(ctx, files)
}

func newGenerator(pkgName string, api *metadata.API) *generator {
	return &generator{pkgName: pkgName, api: api, typeToStruct: make(map[string]string)}
}

func (g *generator) Generate(ctx context.Context) ([]*genFile, error) {
	reg, err := newRegistry(ctx, g.api)
	if err != nil {
		return nil, err
	}

	// Map to sorted slice
	entities := slices.SortedFunc(maps.Values(reg.Entities), func(a *entitySpec, b *entitySpec) int {
		return strings.Compare(a.GoName, b.GoName)
	})

	// Generate common Go file
	var files []*genFile
	files = append(files, g.commonFile(entities))

	// Generate Go file for each entity
	for _, entity := range reg.Entities {
		files = append(files, g.entityFile(entity))
	}

	return files, nil
}
